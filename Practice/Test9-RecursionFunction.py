### 递归函数



## 一个函数在内部调用自身本身，这个函数就是递归函数


#阶乘函数fact(n)用递归的方式写出来就是：

def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)

## 使用递归函数需要注意防止栈溢出。

# 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
# 每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
## 由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

## 解决递归调用栈溢出的方法是通过*尾递归（类似循环）优化
# 循环可看成特殊的递归

## 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
## 编译器/解释器就可以优化尾递归，使递归本身无论调用多少次，都只占用一个栈帧，不会栈溢出

def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

#  因提前计算，不影响函数调用

## 递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出
## 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，
## 没有循环语句的编程语言只能通过尾递归实现循环。

## Python标准的解释器没有针对尾递归做优化，**任何递归函数都存在栈溢出的问题。


## 练习

# 汉诺塔的移动可以用递归函数非常简单地实现。
## https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94/3468295

# 请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量
# 然后打印出把所有盘子从A借助B移动到C的方法，例如：

# -*- coding: utf-8 -*-
def move(n, a, b, c):
    if n == 1:
        print(a, '-->', c)
    else:
        move(n-1,a,c,b)
        move(1,a,b,c)
        move(n-1,b,a,c)
        
## 期待输出:
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C
move(3, 'A', 'B', 'C')

    

# n为偶数，按顺时针方向依次摆放 A B C；
# 若n为奇数，按顺时针方向依次摆放 A C B

# ⑴按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，即当n为偶数时，
#若圆盘1在柱子A，则把它移动到B；若圆盘1在柱子B，则把它移动到C；若圆盘1在柱子C，则把它移动到A。
# ⑵接着，把另外两根柱子上可以移动的圆盘移动到新的柱子上
def hanoi(n,x,y,z):
    if n==1:
        print(x,'-->',z)
    else:
        hanoi(n-1,x,z,y)#将前n-1个盘子从x移动到y上
        hanoi(1,x,y,z)#将最底下的最后一个盘子从x移动到z上
        hanoi(n-1,y,x,z)#将y上的n-1个盘子移动到z上
n=int(input('请输入汉诺塔的层数：'))
hanoi(n,'x','y','z')


B=[] #设置操作过程列表
if n==1:
buzhou=a+str(n)+'-->'+c+str(n) #一个圆盘需要从A到C操作步骤
B.append(buzhou) #向列表中添加操作步骤
return
move(n-1,a,c,b) #将A柱的n-1个盘移到B柱
buzhou=a+str(n)+'-->'+c+str(n) #将A柱的第n个盘移到C柱操作步骤
B.append(buzhou) #向列表中添加操作步骤
move(1,a,b,c) #将A柱上最后一个盘移到C柱
move(n-1,b,a,c) #将过渡柱子B上n-1个圆盘B移动到目标柱子C
move(6，'A','B','C') #2**64-1，64次太大，这里用6个盘子
print('共需操作'+str(len(B))+'次','操作过程为',B)#计算6个盘子的步骤数及操作过程
