### 高级特性

# 构造一个1, 3, 5, 7, ..., 99的列表
L = []
n = 1
while n <= 99:
    L.append(n)
    n = n + 2

## 代码越少，开发效率越高。越简单越好。


## 切片

# 取一个list或tuple的部分元素是非常常见的操作
# 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：

>>> r = []
>>> n = 3
>>> for i in range(n):
...     r.append(L[i])
... 
>>> r
['Michael', 'Sarah', 'Tracy']

# 应上面的问题，取前3个元素，用一行代码就可以完成切片：
>>> L[0:3]                        #相当于字符串中取前三个字符
['Michael', 'Sarah', 'Tracy']

# 如果第一个索引是0，还可以省略：
>>> L[:3]


## Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：

>>> L[-2:]
['Bob', 'Jack']
>>> L[-2:-1]
['Bob']

# 切片操作十分有用。我们先创建一个0-99的数列：

>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]


# 前10个数，每两个取一个：
>>> L[:10:2]
[0, 2, 4, 6, 8]

# 所有数，每5个取一个：
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]

L[::-1] ## 每次都只取最后一个，相当于反转字符串

# 甚至什么都不写，只写[:]就可以原样复制一个list


## tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以切片，只是结果仍是tuple：

>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)

# 字符串'xxx'也可以看成是一种list，每个元素就是一个字符，切片结果也是字符串


## 去边取值时，负数放后面；反向取值时，负数放前边

>>> L=['a','b','c','d']
>>> L[-2:0]
[]
>>> L[-2:-1]
['c']
>>> L[-1:0]
[]
>>> L[-2:]
['c', 'd']



## 练习

# 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：

# -*- coding: utf-8 -*-
def trim(s):
     if s=='':
        return s
     while s[0]== ' ':
        s= s[1:]
        if s=='':     #防止清空成''
          return s   # break
     while s[-1]== ' ':
        s= s[:-1]
        if s=='':      #防止清空成''  用递归的话，先生成奇怪的值，才进判断会报错
          return s    # break
     return s

# 测试:
if trim('hello  ') != 'hello':
    print('测试失败!')
elif trim('  hello') != 'hello':
    print('测试失败!')
elif trim('  hello  ') != 'hello':
    print('测试失败!')
elif trim('  hello  world  ') != 'hello  world':
    print('测试失败!')
elif trim('') != '':
    print('测试失败!')
elif trim('    ') != '':
    print('测试失败!')
else:
    print('测试成功!')

    
# 问题主要集中在第5个测试和第6个测试。第5个测试输入了s=''，
# 如果这里直接调用s[0]，而s一个字符都没有，就会报out of range错。
# 所以，必须要第一个if来解决这个问题。而我解决了这个问题后发现还是测试失败，
# 这是因为第一个循环是while s[0]，在第六个测试中，s='    '，循环的最后一步，s='',
# 再调用s[0]就又会发生out of range错误，所以必须再加一个if来确保不发生索引越界。


